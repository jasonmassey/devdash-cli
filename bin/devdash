#!/usr/bin/env bash
# devdash — Dev-Dash CLI
# Thin wrapper around the dev-dash API for task tracking.
# Usage: devdash <command> [args]

set -euo pipefail

# Clean exit on Ctrl+C — suppress bash noise from errexit + pipefail
trap 'printf "\n"; exit 130' INT

DD_VERSION="0.2.0"
DD_CONFIG_DIR="${DD_CONFIG_DIR:-${HOME}/.config/dev-dash}"
DD_TOKEN_FILE="${DD_TOKEN_FILE:-${DD_CONFIG_DIR}/token}"
DD_PROJECT_FILE=".devdash"

# Exit codes: 0=success, 1=user error, 2=API error, 3=config error
DD_EXIT_USER=1
DD_EXIT_API=2
DD_EXIT_CONFIG=3

# ── Helpers ──────────────────────────────────────────────────────

dd_api_url() {
  if [ -f "$DD_PROJECT_FILE" ]; then
    local url
    url=$(jq -r '.api_url // empty' "$DD_PROJECT_FILE" 2>/dev/null)
    if [ -n "$url" ]; then
      echo "$url"
      return
    fi
  fi
  echo "${DD_API_URL:-https://dev-dash-server-production.up.railway.app}"
}

dd_resolve_project_id() {
  local raw="$1"
  # Full UUID — use directly
  if [[ ${#raw} -eq 36 && "$raw" == *-*-*-*-* ]]; then
    echo "$raw"
    return
  fi
  # Prefix — resolve against project list
  local projects
  projects=$(dd_api GET "/projects" 2>/dev/null) || { echo "$raw"; return; }
  local matches
  matches=$(echo "$projects" | jq -r "[.[] | select(.id | startswith(\"$raw\"))] | .[].id")
  if [ -z "$matches" ]; then
    echo "No project found matching prefix: $raw" >&2
    exit "$DD_EXIT_USER"
  fi
  local count
  count=$(echo "$matches" | wc -l | tr -d ' ')
  if [ "$count" -gt 1 ]; then
    echo "Ambiguous project prefix '$raw' matches $count projects:" >&2
    echo "$matches" | head -5 >&2
    exit "$DD_EXIT_USER"
  fi
  echo "$matches"
}

# Resolve a token ID prefix to a full UUID
dd_resolve_token_id() {
  local token_id="$1"
  # Full UUID — use directly
  if [[ ${#token_id} -eq 36 && "$token_id" == *-*-*-*-* ]]; then
    echo "$token_id"
    return
  fi
  # Short prefix — fetch all tokens and match
  local tokens
  tokens=$(dd_api GET "/auth/tokens")
  local matches
  matches=$(echo "$tokens" | dd_jq -r "[.[] | select(.id | startswith(\"$token_id\"))] | .[].id")
  if [ -z "$matches" ]; then
    echo "No token found matching prefix: $token_id" >&2
    return 1
  fi
  local count
  count=$(echo "$matches" | wc -l | tr -d ' ')
  if [ "$count" -gt 1 ]; then
    echo "Ambiguous token prefix '$token_id' matches $count tokens:" >&2
    echo "$matches" | head -5 >&2
    return 1
  fi
  echo "$matches"
}

dd_project_id() {
  # Explicit env var overrides .devdash file (allows cross-project commands)
  if [ -n "${DD_PROJECT_ID:-}" ]; then
    dd_resolve_project_id "$DD_PROJECT_ID"
    return
  fi
  if [ -f "$DD_PROJECT_FILE" ]; then
    local pid
    pid=$(jq -r '.project_id // empty' "$DD_PROJECT_FILE" 2>/dev/null)
    if [ -n "$pid" ]; then
      echo "$pid"
      return
    fi
  fi
  echo "No project configured. Run: devdash init" >&2
  exit "$DD_EXIT_CONFIG"
}

dd_get_token() {
  if [ -f "$DD_TOKEN_FILE" ]; then
    cat "$DD_TOKEN_FILE"
  else
    echo "Not logged in. Run: devdash login" >&2
    exit "$DD_EXIT_CONFIG"
  fi
}

dd_api() {
  local method=$1 endpoint=$2
  shift 2
  local token url tmpfile http_code body
  token=$(dd_get_token) || return $?
  url="$(dd_api_url)/api${endpoint}"
  tmpfile=$(mktemp)
  http_code=$(curl -s -o "$tmpfile" -w '%{http_code}' -X "$method" \
    -H "Authorization: Bearer ${token}" \
    -H "Content-Type: application/json" \
    "$url" "$@" 2>/dev/null) || {
    rm -f "$tmpfile"
    echo "Error: could not connect to $(dd_api_url)" >&2
    exit "$DD_EXIT_API"
  }
  body=$(cat "$tmpfile")
  rm -f "$tmpfile"

  if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
    echo "$body"
  else
    local msg
    msg=$(echo "$body" | jq -r '.error // .message // empty' 2>/dev/null)
    if [ -n "$msg" ]; then
      echo "API error ($http_code): $msg" >&2
    else
      echo "API error ($http_code): $body" >&2
    fi
    exit "$DD_EXIT_API"
  fi
}

# Safe jq wrapper — handles non-JSON input gracefully
dd_jq() {
  jq "$@" 2>/dev/null || {
    echo "Error: unexpected non-JSON response from API" >&2
    exit "$DD_EXIT_API"
  }
}

# Fetch all beads for a project (handles pagination)
dd_fetch_beads() {
  local pid="$1"
  local all="[]" cursor="" page
  while true; do
    local url="/beads?projectId=${pid}&limit=500"
    [ -n "$cursor" ] && url="${url}&cursor=$(printf '%s' "$cursor" | jq -sRr @uri)"
    page=$(dd_api GET "$url") || return $?
    local data
    data=$(echo "$page" | dd_jq '.data // .')
    all=$(echo "$all" "$data" | jq -s '.[0] + .[1]')
    cursor=$(echo "$page" | dd_jq -r '.nextCursor // empty')
    if [ -z "$cursor" ] || [ "$cursor" = "null" ]; then
      break
    fi
  done
  echo "$all"
}

# Fetch all jobs for a project (unwraps paginated response)
dd_fetch_jobs() {
  local pid="$1" result
  result=$(dd_api GET "/jobs?projectId=${pid}") || return $?
  echo "$result" | dd_jq '.data // .'
}

# Resolve a bead ID: handles dev-dash-* local IDs and UUID prefixes
# Usage: uuid=$(dd_resolve_id "$bead_id" "$project_id" ["$cached_beads"])
# Pass cached_beads (JSON array) as $3 to skip the API fetch.
dd_resolve_id() {
  local bead_id="$1" pid="$2" cached_beads="${3:-}"

  # Full UUID (36 chars with dashes) — use directly
  if [[ ${#bead_id} -eq 36 && "$bead_id" == *-*-*-*-* ]]; then
    echo "$bead_id"
    return
  fi

  # Need beads for local ID or prefix lookup
  local all_beads
  if [ -n "$cached_beads" ]; then
    all_beads="$cached_beads"
  else
    all_beads=$(dd_fetch_beads "$pid")
  fi

  # dev-dash-* local IDs — resolve via localBeadId field
  if [[ "$bead_id" == dev-dash-* ]]; then
    local uuid
    uuid=$(echo "$all_beads" | jq -r ".[] | select(.localBeadId == \"$bead_id\") | .id")
    if [ -z "$uuid" ]; then
      echo "Bead not found: $bead_id" >&2
      return 1
    fi
    echo "$uuid"
    return
  fi

  # Short prefix — match against all beads
  local matches
  matches=$(echo "$all_beads" | jq -r "[.[] | select(.id | startswith(\"$bead_id\"))] | .[].id")

  if [ -z "$matches" ]; then
    echo "Bead not found matching prefix: $bead_id" >&2
    return 1
  fi

  local count
  count=$(echo "$matches" | wc -l | tr -d ' ')

  if [ "$count" -gt 1 ]; then
    echo "Ambiguous prefix '$bead_id' matches $count beads:" >&2
    echo "$matches" | head -5 >&2
    return 1
  fi

  echo "$matches"
}

# ── Detect command name ──────────────────────────────────────────
# If user has 'dd' aliased to devdash, use 'dd' in output; otherwise 'devdash'
dd_cmd_name() {
  if alias dd 2>/dev/null | grep -q devdash 2>/dev/null; then
    echo "dd"
  elif type dd 2>/dev/null | grep -q devdash 2>/dev/null; then
    echo "dd"
  else
    echo "devdash"
  fi
}

# ── Commands ─────────────────────────────────────────────────────

dd_version() {
  echo "devdash ${DD_VERSION}"
}

dd_login() {
  local nonce
  nonce=$(openssl rand -hex 16)
  local tmpfile
  tmpfile=$(mktemp)
  local api_url
  api_url=$(dd_api_url)

  # Find an available port (try 18787-18792)
  local port=""
  for try_port in 18787 18788 18789 18790 18791 18792; do
    if ! python3 -c "import socket; s=socket.socket(); s.settimeout(0.1); s.connect(('127.0.0.1',$try_port)); s.close()" 2>/dev/null; then
      port=$try_port
      break
    fi
  done
  if [ -z "$port" ]; then
    echo "Error: all callback ports 18787-18792 are in use" >&2
    exit "$DD_EXIT_CONFIG"
  fi

  # Start a temporary Python HTTP server for the OAuth callback (120s timeout)
  python3 -c "
import http.server, urllib.parse, threading, signal, sys

# Exit cleanly on SIGTERM/SIGINT — no traceback
signal.signal(signal.SIGTERM, lambda *a: sys.exit(0))
signal.signal(signal.SIGINT, lambda *a: sys.exit(0))

class H(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        qs = urllib.parse.parse_qs(urllib.parse.urlparse(self.path).query)
        token = (qs.get('token') or [None])[0]
        nonce_rx = (qs.get('nonce') or [None])[0]
        if token and nonce_rx == '${nonce}':
            with open('${tmpfile}', 'w') as f:
                f.write(token)
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(b'''<html><body style=\"font-family:system-ui;display:flex;justify-content:center;align-items:center;height:100vh;margin:0\">
<div style=\"text-align:center\"><h1>Authenticated!</h1><p>You can close this tab and return to your terminal.</p></div>
</body></html>''')
        else:
            self.send_response(400)
            self.end_headers()
            self.wfile.write(b'Invalid callback')
        threading.Thread(target=self.server.shutdown).start()
    def log_message(self, *a): pass

s = http.server.HTTPServer(('127.0.0.1', ${port}), H)
# Auto-shutdown after 120s if no callback received
threading.Timer(120, s.shutdown).start()
s.serve_forever()
" &
  local server_pid=$!

  # Clean up server on Ctrl+C
  trap 'printf "\nCancelled.\n"; kill $server_pid 2>/dev/null; rm -f "$tmpfile"; exit 130' INT

  local url="${api_url}/api/auth/cli-token?port=${port}&nonce=${nonce}"
  echo "Opening browser for authentication..."
  echo "Waiting for callback (up to 2 minutes)..."
  open "$url" 2>/dev/null || xdg-open "$url" 2>/dev/null || echo "Open this URL in your browser: $url"

  # Wait for server to exit (callback received or timeout)
  wait "$server_pid" 2>/dev/null || true
  trap - INT

  if [ -s "$tmpfile" ]; then
    mkdir -p "$DD_CONFIG_DIR"
    cp "$tmpfile" "$DD_TOKEN_FILE"
    chmod 600 "$DD_TOKEN_FILE"
    rm -f "$tmpfile"
    echo "Logged in successfully! Token stored in ${DD_TOKEN_FILE}"

    # Auto-init if in a git repo without .devdash
    if [ ! -f "$DD_PROJECT_FILE" ] && git rev-parse --is-inside-work-tree &>/dev/null; then
      echo ""
      dd_init
    fi
  else
    rm -f "$tmpfile"
    echo "Login failed or timed out." >&2
    exit "$DD_EXIT_API"
  fi
}

dd_init() {
  # Detect GitHub remote
  local remote=""
  if git rev-parse --is-inside-work-tree &>/dev/null; then
    remote=$(git remote get-url origin 2>/dev/null | sed -E 's#.*github\.com[:/](.*)\.git$#\1#; s#.*github\.com[:/](.*)$#\1#') || remote=""
  fi

  # Fetch projects
  local projects
  projects=$(dd_api GET "/projects" 2>/dev/null) || {
    echo "Failed to fetch projects. Are you logged in? Run: devdash login" >&2
    exit "$DD_EXIT_API"
  }

  # Try auto-match by GitHub repo
  if [ -n "$remote" ]; then
    local pid
    pid=$(echo "$projects" | jq -r ".[] | select(.githubRepo == \"$remote\") | .id" 2>/dev/null | head -1)
    if [ -n "$pid" ]; then
      local pname
      pname=$(echo "$projects" | jq -r ".[] | select(.id == \"$pid\") | .name" 2>/dev/null)
      local api_url
      api_url=$(dd_api_url)
      echo "{\"api_url\": \"${api_url}\", \"project_id\": \"${pid}\"}" > "$DD_PROJECT_FILE"
      echo "Initialized: ${pname} (${remote}) -> ${pid}"
      dd_maybe_offer_alias
      return
    fi
  fi

  # List projects for manual selection
  echo "No auto-match for remote '${remote}'. Available projects:"
  echo "$projects" | jq -r '.[] | "  \(.id)  \(.name)  (\(.githubRepo // "no repo"))"'
  echo ""
  echo "Set manually: echo '{\"api_url\": \"...\", \"project_id\": \"...\"}' > .devdash"
}

dd_list() {
  local pid
  pid=$(dd_project_id)
  local status_filter="${1:-}"
  local beads
  beads=$(dd_fetch_beads "$pid")

  if [ -n "$status_filter" ]; then
    # Accept --status=X or just a status word
    status_filter="${status_filter#--status=}"
    beads=$(echo "$beads" | jq "[.[] | select(.status == \"$status_filter\")]")
  fi

  echo "$beads" | jq -r '.[] | "\(.status | if . == "pending" then "○" elif . == "in_progress" then "●" elif . == "completed" then "✓" else "?" end) \(.localBeadId // .id) [P\(.priority)] [\(.beadType // "task")] - \(.subject)\(if (.blockedBy | length) > 0 then " (blocked)" else "" end)"'
}

dd_ready() {
  local pid
  pid=$(dd_project_id)
  local beads
  beads=$(dd_fetch_beads "$pid")

  echo "$beads" | jq -r '
    ([.[] | select(.status == "completed") | .id]) as $done |
    [.[] | select(.status == "pending")
         | select((.blockedBy | length) == 0 or ([.blockedBy[] | IN($done[])] | all))]
    | sort_by(.priority)
    | .[]
    | "○ \(.localBeadId // .id) [P\(.priority)] [\(.beadType // "task")] - \(.subject)"
  '
}

dd_show() {
  if [ -z "${1:-}" ]; then
    echo "Usage: devdash show <bead-id>" >&2
    exit "$DD_EXIT_USER"
  fi
  local pid
  pid=$(dd_project_id)
  local uuid
  uuid=$(dd_resolve_id "$1" "$pid") || exit 1

  local bead
  bead=$(dd_api GET "/beads/${uuid}?projectId=${pid}")

  echo "$bead" | jq '{
    id: .id,
    localId: .localBeadId,
    subject: .subject,
    description: .description,
    status: .status,
    priority: .priority,
    owner: .owner,
    beadType: .beadType,
    parentBeadId: .parentBeadId,
    blockedBy: .blockedBy,
    blocks: .blocks,
    preInstructions: .preInstructions,
    createdAt: .createdAt,
    updatedAt: .updatedAt
  }'
}

dd_create() {
  local pid
  pid=$(dd_project_id)
  local title="" type="task" priority=2 description="" parent=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title=*) title="${1#--title=}" ;;
      --type=*) type="${1#--type=}" ;;
      --priority=*) priority="${1#--priority=}" ;;
      --description=*) description="${1#--description=}" ;;
      --parent=*) parent="${1#--parent=}" ;;
      *) title="$1" ;;
    esac
    shift
  done

  if [ -z "$title" ]; then
    echo "Usage: devdash create --title=\"...\" [--type=task|bug|feature] [--priority=0-4] [--description=\"...\"]" >&2
    exit "$DD_EXIT_USER"
  fi

  # Resolve parent short ID to full UUID
  if [ -n "$parent" ]; then
    parent=$(dd_resolve_id "$parent" "$pid") || exit 1
  fi

  local body
  body=$(jq -n \
    --arg projectId "$pid" \
    --arg subject "$title" \
    --arg description "$description" \
    --argjson priority "$priority" \
    --arg beadType "$type" \
    --arg parentBeadId "$parent" \
    '{projectId: $projectId, subject: $subject, description: $description, priority: $priority, beadType: $beadType} + (if $parentBeadId != "" then {parentBeadId: $parentBeadId} else {} end)')

  local result
  result=$(dd_api POST "/beads" -d "$body")
  local id
  id=$(echo "$result" | jq -r '.id')
  local subject
  subject=$(echo "$result" | jq -r '.subject')
  echo "Created: ${id} - ${subject}"
}

dd_update() {
  local bead_id="$1"
  shift
  local pid
  pid=$(dd_project_id)
  local uuid
  uuid=$(dd_resolve_id "$bead_id" "$pid") || exit 1

  local body
  body=$(jq -n --arg pid "$pid" '{projectId: $pid}')

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --status=*) body=$(echo "$body" | jq --arg v "${1#--status=}" '. + {status: $v}') ;;
      --priority=*) body=$(echo "$body" | jq --argjson v "${1#--priority=}" '. + {priority: $v}') ;;
      --owner=*) body=$(echo "$body" | jq --arg v "${1#--owner=}" '. + {owner: $v}') ;;
      --title=*) body=$(echo "$body" | jq --arg v "${1#--title=}" '. + {subject: $v}') ;;
      --description=*) body=$(echo "$body" | jq --arg v "${1#--description=}" '. + {description: $v}') ;;
      --pre-instructions=*) body=$(echo "$body" | jq --arg v "${1#--pre-instructions=}" '. + {preInstructions: $v}') ;;
      --parent=*)
        local parent_uuid
        parent_uuid=$(dd_resolve_id "${1#--parent=}" "$pid") || exit 1
        body=$(echo "$body" | jq --arg v "$parent_uuid" '. + {parentBeadId: $v}')
        ;;
    esac
    shift
  done

  dd_api PATCH "/beads/${uuid}" -d "$body" > /dev/null
  echo "Updated: ${uuid}"
}

dd_close() {
  local pid
  pid=$(dd_project_id)

  for bead_id in "$@"; do
    local uuid
    uuid=$(dd_resolve_id "$bead_id" "$pid") || { echo "Skipping: $bead_id" >&2; continue; }
    dd_api PATCH "/beads/${uuid}" -d "{\"projectId\": \"${pid}\", \"status\": \"completed\"}" > /dev/null
    echo "Closed: ${uuid}"
  done
}

dd_delete() {
  local force=false
  local cascade=false
  local bead_ids=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force|-f) force=true ;;
      --cascade) cascade=true ;;
      *) bead_ids+=("$1") ;;
    esac
    shift
  done

  if [ ${#bead_ids[@]} -eq 0 ]; then
    echo "Usage: devdash delete <bead-id> [<bead-id>...] [--force] [--cascade]" >&2
    exit "$DD_EXIT_USER"
  fi

  local pid
  pid=$(dd_project_id)
  local cascade_param=""
  [ "$cascade" = true ] && cascade_param="&cascade=true"

  for bead_id in "${bead_ids[@]}"; do
    local uuid
    uuid=$(dd_resolve_id "$bead_id" "$pid") || { echo "Skipping: $bead_id" >&2; continue; }

    if [ "$force" != true ]; then
      local bead subject
      bead=$(dd_api GET "/beads/${uuid}?projectId=${pid}")
      subject=$(echo "$bead" | dd_jq -r '.subject')
      if [ "$cascade" = true ]; then
        printf "Delete '%s' and all children? [y/N] " "$subject"
      else
        printf "Delete '%s'? [y/N] " "$subject"
      fi
      read -r answer </dev/tty 2>/dev/null || answer="n"
      case "$answer" in
        [Yy]|[Yy]es) ;;
        *) echo "Skipped: $bead_id"; continue ;;
      esac
    fi

    dd_api DELETE "/beads/${uuid}?projectId=${pid}${cascade_param}" > /dev/null
    echo "Deleted: ${uuid}"
  done
}

dd_dep_add() {
  local issue="$1" depends_on="$2"
  local pid
  pid=$(dd_project_id)

  # Fetch beads once, reuse for both resolves and dependency lookup
  local all_beads
  all_beads=$(dd_fetch_beads "$pid")

  local issue_uuid dep_uuid
  issue_uuid=$(dd_resolve_id "$issue" "$pid" "$all_beads") || exit 1
  dep_uuid=$(dd_resolve_id "$depends_on" "$pid" "$all_beads") || exit 1

  # Get current blockedBy for the issue
  local current
  current=$(echo "$all_beads" | jq ".[] | select(.id == \"$issue_uuid\")")
  local blocked_by
  blocked_by=$(echo "$current" | jq -c ".blockedBy + [\"$dep_uuid\"] | unique")

  # Get current blocks for the dependency
  local dep_current
  dep_current=$(echo "$all_beads" | jq ".[] | select(.id == \"$dep_uuid\")")
  local blocks
  blocks=$(echo "$dep_current" | jq -c ".blocks + [\"$issue_uuid\"] | unique")

  # Update both
  dd_api PATCH "/beads/${issue_uuid}" -d "{\"projectId\": \"${pid}\", \"blockedBy\": ${blocked_by}}" > /dev/null
  dd_api PATCH "/beads/${dep_uuid}" -d "{\"projectId\": \"${pid}\", \"blocks\": ${blocks}}" > /dev/null
  echo "Added dependency: ${issue} depends on ${depends_on}"
}

dd_stats() {
  local pid
  pid=$(dd_project_id)
  local beads
  beads=$(dd_fetch_beads "$pid")

  local total pending in_progress completed blocked ready
  total=$(echo "$beads" | jq 'length')
  pending=$(echo "$beads" | jq '[.[] | select(.status == "pending")] | length')
  in_progress=$(echo "$beads" | jq '[.[] | select(.status == "in_progress")] | length')
  completed=$(echo "$beads" | jq '[.[] | select(.status == "completed")] | length')
  blocked=$(echo "$beads" | jq '
    ([.[] | select(.status == "completed") | .id]) as $done |
    [.[] | select(.status == "pending" and (.blockedBy | length) > 0)
         | select([.blockedBy[] | IN($done[])] | all | not)]
    | length')
  ready=$(echo "$beads" | jq '
    ([.[] | select(.status == "completed") | .id]) as $done |
    [.[] | select(.status == "pending")
         | select((.blockedBy | length) == 0 or ([.blockedBy[] | IN($done[])] | all))]
    | length')

  echo "Total:       ${total}"
  echo "Pending:     ${pending}"
  echo "In Progress: ${in_progress}"
  echo "Completed:   ${completed}"
  echo "Blocked:     ${blocked}"
  echo "Ready:       ${ready}"
}

dd_jobs() {
  local pid
  pid=$(dd_project_id)
  local subcmd="${1:-list}"

  case "$subcmd" in
    list)
      local jobs
      jobs=$(dd_fetch_jobs "$pid")
      echo "$jobs" | jq -r '.[] | "\(.status | if . == "completed" then "✓" elif . == "failed" then "✗" elif . == "running" then "●" else "○" end) \(.id[0:8]) [\(.status)] \(.prompt[0:70] // "no prompt")... \(.created_at // "")"'
      ;;
    show)
      if [ -z "${2:-}" ]; then
        echo "Usage: devdash jobs show <job-id>" >&2
        exit "$DD_EXIT_USER"
      fi
      local job
      job=$(dd_api GET "/jobs/${2}")
      echo "$job" | jq '{
        id: .id,
        beadId: .bead_id,
        status: .status,
        workerType: .worker_type,
        createdAt: .created_at,
        startedAt: .started_at,
        completedAt: .completed_at,
        error: .error,
        failureAnalysis: .failureAnalysis
      }'
      ;;
    log)
      if [ -z "${2:-}" ]; then
        echo "Usage: devdash jobs log <job-id>" >&2
        exit "$DD_EXIT_USER"
      fi
      local job
      job=$(dd_api GET "/jobs/${2}")
      echo "$job" | jq -r '.output_log // "No log available"'
      ;;
    failures)
      local jobs
      jobs=$(dd_fetch_jobs "$pid")
      echo "$jobs" | jq -r '[.[] | select(.status == "failed")] | sort_by(.created_at) | reverse | .[:10] | .[] | "✗ \(.id[0:8]) \(.error // "unknown error" | .[0:80])  \(.created_at // "")"'
      ;;
    *)
      echo "Usage: devdash jobs [list|show <id>|log <id>|failures]" >&2
      exit "$DD_EXIT_USER"
      ;;
  esac
}

dd_analyze() {
  if [ -z "${1:-}" ]; then
    echo "Usage: devdash analyze <bead-id>" >&2
    exit "$DD_EXIT_USER"
  fi

  local pid
  pid=$(dd_project_id)
  local bead_id="$1"
  local uuid
  uuid=$(dd_resolve_id "$bead_id" "$pid") || exit 1

  # Fetch the bead to get prompt text
  local bead
  bead=$(dd_api GET "/beads/${uuid}?projectId=${pid}")
  local prompt subject description
  subject=$(echo "$bead" | dd_jq -r '.subject')
  description=$(echo "$bead" | dd_jq -r '.description // empty | select(length > 0)')
  # Always use subject + description for analysis prompt (not preInstructions).
  # The analyzer needs to see the task intent, not stale agent instructions.
  if [ -n "$description" ]; then
    prompt="${subject}

${description}"
  else
    prompt="$subject"
  fi

  echo "Analyzing: ${subject}" >&2
  echo "" >&2

  local body
  body=$(jq -n \
    --arg projectId "$pid" \
    --arg beadId "$uuid" \
    --arg prompt "$prompt" \
    '{projectId: $projectId, beadId: $beadId, prompt: $prompt}')

  local result
  result=$(dd_api POST "/jobs/analyze" -d "$body")

  # Display analysis
  echo "$result" | dd_jq -r '"Complexity:  \(.estimatedComplexity)
Files:       \(.affectedFiles | join(", "))
Modules:     \(.affectedModules | join(", "))
Subdivide:   \(.shouldSubdivide)

## Reasoning
\(.reasoning)

## Agent Instructions
\(.agentInstructions)"'

  # Show if subtasks were created
  local decomposed
  decomposed=$(echo "$result" | dd_jq -r '.decomposed // empty')
  if [ -n "$decomposed" ] && [ "$decomposed" != "null" ]; then
    echo ""
    echo "## Decomposed into subtasks:"
    echo "$decomposed" | dd_jq -r '.[] | "  - \(.id[0:8]) \(.subject)"'
  fi
}

dd_dispatch() {
  if [ -z "${1:-}" ]; then
    echo "Usage: devdash dispatch <bead-id> [--priority=N] [--worker=e2b|docker|railway]" >&2
    exit "$DD_EXIT_USER"
  fi

  local pid
  pid=$(dd_project_id)
  local bead_id="$1"
  shift
  local priority="" worker=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --priority=*) priority="${1#--priority=}" ;;
      --worker=*) worker="${1#--worker=}" ;;
    esac
    shift
  done

  local uuid
  uuid=$(dd_resolve_id "$bead_id" "$pid") || exit 1

  # Fetch the bead to get prompt from preInstructions or description
  local bead
  bead=$(dd_api GET "/beads/${uuid}?projectId=${pid}")
  local prompt subject
  prompt=$(echo "$bead" | dd_jq -r '(.preInstructions // empty), (.description // empty), .subject | select(length > 0)' | head -1)
  subject=$(echo "$bead" | dd_jq -r '.subject')

  local body
  body=$(jq -n \
    --arg projectId "$pid" \
    --arg beadId "$uuid" \
    --arg prompt "$prompt" \
    '{projectId: $projectId, beadId: $beadId, prompt: $prompt}')

  if [ -n "$priority" ]; then
    body=$(echo "$body" | jq --argjson p "$priority" '. + {priority: $p}')
  fi
  if [ -n "$worker" ]; then
    body=$(echo "$body" | jq --arg w "$worker" '. + {workerType: $w}')
  fi

  local result
  result=$(dd_api POST "/jobs" -d "$body")
  local job_id status mode
  job_id=$(echo "$result" | dd_jq -r '.id // .run.id // empty')
  status=$(echo "$result" | dd_jq -r '.status // .run.status // empty')
  mode=$(echo "$result" | dd_jq -r '.dispatchMode // "unknown"')

  if [ -z "$job_id" ]; then
    echo "Dispatch response:" >&2
    echo "$result" | dd_jq '.' >&2
    echo "Error: no job ID in response" >&2
    exit "$DD_EXIT_API"
  fi

  echo "Dispatched: ${subject}"
  echo "  Job:    ${job_id}"
  echo "  Status: ${status}"
  echo "  Mode:   ${mode}"
  echo "  Bead:   ${uuid}"
}

dd_blocked() {
  local pid
  pid=$(dd_project_id)
  local beads
  beads=$(dd_fetch_beads "$pid")

  echo "$beads" | jq -r '
    # Build lookup of completed bead IDs
    ([.[] | select(.status == "completed") | .id]) as $done |
    [.[] | select(.status == "pending" and (.blockedBy | length) > 0)
         | select([.blockedBy[] | IN($done[])] | all | not)]
    | sort_by(.priority)
    | .[]
    | "○ \(.localBeadId // .id) [P\(.priority)] - \(.subject)  blocked by: \(.blockedBy | join(", "))"
  '
}

dd_sync() {
  local pid
  pid=$(dd_project_id)
  echo "Triggering reconcile..."
  local result
  result=$(dd_api POST "/sync/${pid}/sync-all" -d '{}')
  echo "$result" | jq '.'
}

dd_reconcile_tasks() {
  local pid
  pid=$(dd_project_id)
  local dry_run=true
  local auto_fix=false
  local json_output=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --auto-fix) auto_fix=true; dry_run=false ;;
      --dry-run) dry_run=true ;;
      --json) json_output=true ;;
    esac
    shift
  done

  local body
  body=$(jq -n \
    --arg projectId "$pid" \
    --argjson dryRun "$dry_run" \
    --argjson autoFix "$auto_fix" \
    '{projectId: $projectId, dryRun: $dryRun, autoFix: $autoFix}')

  echo "Auditing backlog..." >&2
  local result
  result=$(dd_api POST "/jobs/reconcile-tasks" -d "$body")

  if [ "$json_output" = true ]; then
    echo "$result" | jq '.'
    return
  fi

  # Display summary
  local total scanned duration
  total=$(echo "$result" | jq '.findings | length')
  scanned=$(echo "$result" | jq '.totalBeadsScanned')
  duration=$(echo "$result" | jq '.durationMs')

  echo ""
  echo "Scanned ${scanned} tasks in ${duration}ms — found ${total} finding(s)"
  echo ""

  if [ "$total" -eq 0 ]; then
    echo "No issues found — backlog looks clean!"
    return
  fi

  # Display summary counts
  echo "$result" | jq -r '"  Dependency issues: \(.summary.dependencyIssues)
  Stale tasks:        \(.summary.stale)
  Redundant tasks:    \(.summary.redundant)
  Likely completed:   \(.summary.likelyCompleted)
  Orphaned tasks:     \(.summary.orphaned)
  Auto-fixable:       \(.summary.autoFixable)"'
  echo ""

  # Group findings by type
  for ftype in dependency_issue stale redundant likely_completed orphaned superseded; do
    local count
    count=$(echo "$result" | jq "[.findings[] | select(.type == \"$ftype\")] | length")
    if [ "$count" -eq 0 ]; then continue; fi

    local label
    case "$ftype" in
      dependency_issue) label="Dependency Issues" ;;
      stale) label="Stale Tasks" ;;
      redundant) label="Redundant Tasks" ;;
      likely_completed) label="Likely Completed" ;;
      orphaned) label="Orphaned Tasks" ;;
      superseded) label="Superseded Tasks" ;;
    esac

    echo "── ${label} (${count}) ──"
    echo "$result" | jq -r ".findings[] | select(.type == \"$ftype\") | \"  [\(.severity)] \(.beadSubject)\n    → \(.reason)\(if .relatedBeadId then \"\n    related: \(.relatedBeadId[0:8])...\" else \"\" end)\""
    echo ""
  done

  if [ "$auto_fix" = true ]; then
    local fixed
    fixed=$(echo "$result" | jq '.summary.autoFixable')
    echo "Applied ${fixed} auto-fix(es)"
  elif [ "$(echo "$result" | jq '.summary.autoFixable')" -gt 0 ]; then
    echo "Run with --auto-fix to fix dependency issues automatically"
  fi
}

dd_project_create() {
  local name="" repo="" description=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --name=*) name="${1#--name=}" ;;
      --repo=*) repo="${1#--repo=}" ;;
      --description=*) description="${1#--description=}" ;;
      *) name="$1" ;;
    esac
    shift
  done

  if [ -z "$name" ]; then
    echo "Usage: devdash project create --name=\"...\" [--repo=owner/repo] [--description=\"...\"]" >&2
    exit "$DD_EXIT_USER"
  fi

  local body
  body=$(jq -n \
    --arg name "$name" \
    --arg githubRepo "$repo" \
    --arg description "$description" \
    '{name: $name} + (if $githubRepo != "" then {githubRepo: $githubRepo} else {} end) + (if $description != "" then {description: $description} else {} end)')

  local result
  result=$(dd_api POST "/projects" -d "$body")
  local id
  id=$(echo "$result" | jq -r '.id')
  local pname
  pname=$(echo "$result" | jq -r '.name')
  echo "Created project: ${id} - ${pname}"

  # Auto-write .devdash if in a git repo
  if git rev-parse --is-inside-work-tree &>/dev/null && [ ! -f "$DD_PROJECT_FILE" ]; then
    local api_url
    api_url=$(dd_api_url)
    echo "{\"api_url\": \"${api_url}\", \"project_id\": \"${id}\"}" > "$DD_PROJECT_FILE"
    echo "Linked: .devdash -> ${id}"
  fi
}

dd_project_list() {
  local projects
  projects=$(dd_api GET "/projects" 2>/dev/null) || {
    echo "Failed to fetch projects. Are you logged in? Run: devdash login" >&2
    exit "$DD_EXIT_API"
  }
  echo "$projects" | jq -r '.[] | "\(.id)  \(.name)  (\(.githubRepo // "no repo"))"'
}

dd_project_delete() {
  local force=false
  local project_id=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force|-f) force=true ;;
      *) project_id="$1" ;;
    esac
    shift
  done

  if [ -z "$project_id" ]; then
    echo "Usage: devdash project delete <project-id> [--force]" >&2
    exit "$DD_EXIT_USER"
  fi

  # Resolve short prefix to full UUID
  project_id=$(dd_resolve_project_id "$project_id")

  if [ "$force" != true ]; then
    local project pname
    project=$(dd_api GET "/projects/${project_id}")
    pname=$(echo "$project" | dd_jq -r '.name')
    printf "Delete project '%s'? This cannot be undone. [y/N] " "$pname"
    read -r answer </dev/tty 2>/dev/null || answer="n"
    case "$answer" in
      [Yy]|[Yy]es) ;;
      *) echo "Cancelled."; return ;;
    esac
  fi

  dd_api DELETE "/projects/${project_id}" > /dev/null
  echo "Deleted project: ${project_id}"
}

dd_doctor() {
  local ok=true
  echo "devdash doctor — checking prerequisites"
  echo ""
  for cmd in curl jq openssl python3 git; do
    if command -v "$cmd" &>/dev/null; then
      echo "  ✓ $cmd: $(command -v "$cmd")"
    else
      echo "  ✗ $cmd: NOT FOUND"
      ok=false
    fi
  done
  echo ""
  # Check config
  if [ -f "$DD_TOKEN_FILE" ]; then
    echo "  ✓ auth token: ${DD_TOKEN_FILE}"
  else
    echo "  ○ auth token: not found (run 'devdash login')"
  fi
  if [ -f "$DD_PROJECT_FILE" ]; then
    echo "  ✓ project config: ${DD_PROJECT_FILE}"
  else
    echo "  ○ project config: not found (run 'devdash init')"
  fi
  # Check server connectivity + auth
  if [ -f "$DD_TOKEN_FILE" ]; then
    local api_base
    api_base=$(dd_api_url 2>/dev/null) || api_base=""
    if [ -n "$api_base" ]; then
      local token health_code auth_code
      token=$(cat "$DD_TOKEN_FILE")
      health_code=$(curl -s -o /dev/null -w '%{http_code}' "${api_base}/api/health" 2>/dev/null) || health_code="000"
      if [ "$health_code" = "200" ]; then
        echo "  ✓ server: ${api_base} (reachable)"
        auth_code=$(curl -s -o /dev/null -w '%{http_code}' -H "Authorization: Bearer ${token}" "${api_base}/api/projects" 2>/dev/null) || auth_code="000"
        if [ "$auth_code" -ge 200 ] && [ "$auth_code" -lt 300 ]; then
          echo "  ✓ auth: token accepted"
        else
          echo "  ✗ auth: token rejected (HTTP ${auth_code}) — run 'devdash login'"
          ok=false
        fi
      else
        echo "  ✗ server: ${api_base} (HTTP ${health_code})"
        ok=false
      fi
    fi
  fi
  echo ""
  # Check if dd alias exists
  if alias dd 2>/dev/null | grep -q devdash 2>/dev/null; then
    echo "  ✓ dd alias: active"
  elif type dd 2>/dev/null | grep -q devdash 2>/dev/null; then
    echo "  ✓ dd alias: active (via PATH/function)"
  else
    echo "  ○ dd alias: not set (run 'devdash alias-setup' to configure)"
  fi
  echo ""
  $ok && echo "All good!" || echo "Missing dependencies above."
}

dd_maybe_offer_alias() {
  # Skip in non-interactive environments
  [ -t 0 ] || return 0

  local shell_name shell_rc
  shell_name=$(basename "${SHELL:-/bin/bash}")
  case "$shell_name" in
    zsh)  shell_rc="${HOME}/.zshrc" ;;
    bash)
      if [ -f "${HOME}/.bashrc" ]; then shell_rc="${HOME}/.bashrc"
      else shell_rc="${HOME}/.bash_profile"; fi ;;
    fish) shell_rc="${HOME}/.config/fish/config.fish" ;;
    *)    shell_rc="${HOME}/.${shell_name}rc" ;;
  esac

  # Already configured — nothing to do
  if grep -q 'alias dd=devdash' "$shell_rc" 2>/dev/null; then
    return 0
  fi

  echo ""
  echo "Tip: alias 'dd' → 'devdash' for shorter commands?"
  echo "  (shadows /usr/bin/dd — skip if you use that tool)"
  printf "Add alias to ${shell_rc}? [Y/n] "
  read -r answer </dev/tty 2>/dev/null || answer="n"
  answer="${answer:-y}"

  case "$answer" in
    [Yy]|[Yy]es|"")
      echo "" >> "$shell_rc"
      echo "# devdash: alias dd -> devdash" >> "$shell_rc"
      echo "alias dd=devdash" >> "$shell_rc"
      echo "Added! Run 'source ${shell_rc}' or restart your terminal."
      ;;
    *)
      echo "Skipped. Run 'devdash alias-setup' anytime."
      ;;
  esac
}

dd_alias_setup() {
  local shell_name shell_rc

  # Detect shell
  shell_name=$(basename "${SHELL:-/bin/bash}")
  case "$shell_name" in
    zsh)  shell_rc="${HOME}/.zshrc" ;;
    bash)
      if [ -f "${HOME}/.bashrc" ]; then
        shell_rc="${HOME}/.bashrc"
      else
        shell_rc="${HOME}/.bash_profile"
      fi
      ;;
    fish) shell_rc="${HOME}/.config/fish/config.fish" ;;
    *)    shell_rc="${HOME}/.${shell_name}rc" ;;
  esac

  echo "This will add 'alias dd=devdash' to ${shell_rc}"
  echo ""
  echo "  Note: this shadows /usr/bin/dd (Unix disk copy utility)."
  echo "  Only do this if you don't use that tool."
  echo ""

  # Check if already set
  if grep -q 'alias dd=devdash' "$shell_rc" 2>/dev/null; then
    echo "Alias already exists in ${shell_rc} — nothing to do."
    return
  fi

  printf "Add alias? [Y/n] "
  read -r answer </dev/tty 2>/dev/null || answer="y"
  answer="${answer:-y}"

  case "$answer" in
    [Yy]|[Yy]es|"")
      echo "" >> "$shell_rc"
      echo "# devdash: alias dd -> devdash" >> "$shell_rc"
      echo "alias dd=devdash" >> "$shell_rc"
      echo ""
      echo "Added to ${shell_rc}. Run 'source ${shell_rc}' or restart your terminal."
      ;;
    *)
      echo "Skipped. You can always run 'devdash alias-setup' later."
      ;;
  esac
}

dd_self_update() {
  if command -v npm &>/dev/null; then
    echo "Updating via npm..."
    npm update -g devdash-cli
  else
    echo "npm not found. Install Node.js or update manually." >&2
    exit "$DD_EXIT_CONFIG"
  fi
  echo "Updated to $(devdash --version)"
}

dd_prime() {
  # Detect preferred command name
  local dd_cmd
  dd_cmd=$(dd_cmd_name)

  # Gather project context if available
  local project_header=""
  if [ -f "$DD_PROJECT_FILE" ] && [ -f "$DD_TOKEN_FILE" ]; then
    local pid
    pid=$(jq -r '.project_id // empty' "$DD_PROJECT_FILE" 2>/dev/null)
    if [ -n "$pid" ]; then
      local project_info
      project_info=$(dd_api GET "/projects/${pid}" 2>/dev/null) || true
      if [ -n "$project_info" ]; then
        local pname prepo
        pname=$(echo "$project_info" | jq -r '.name // "unknown"' 2>/dev/null)
        prepo=$(echo "$project_info" | jq -r '.githubRepo // empty' 2>/dev/null)
        project_header="**Project**: ${pname}"
        if [ -n "$prepo" ]; then
          project_header="${project_header} (${prepo})"
        fi
        project_header="${project_header}  |  **ID**: \`${pid:0:8}\`"
      fi

      local beads
      beads=$(dd_fetch_beads "$pid" 2>/dev/null) || true
      if [ -n "$beads" ]; then
        local open ip blocked
        open=$(echo "$beads" | jq '[.[] | select(.status != "completed")] | length' 2>/dev/null)
        ip=$(echo "$beads" | jq '[.[] | select(.status == "in_progress")] | length' 2>/dev/null)
        blocked=$(echo "$beads" | jq '
          ([.[] | select(.status == "completed") | .id]) as $done |
          [.[] | select(.status == "pending" and (.blockedBy | length) > 0)
               | select([.blockedBy[] | IN($done[])] | all | not)]
          | length' 2>/dev/null)
        project_header="${project_header}
**Health**: ${open:-0} open, ${ip:-0} in progress, ${blocked:-0} blocked"
      fi
    fi

    # Fetch all projects for cross-repo reference table
    local all_projects
    all_projects=$(dd_api GET "/projects" 2>/dev/null) || true
    if [ -n "$all_projects" ] && echo "$all_projects" | jq -e 'type == "array" and length > 0' >/dev/null 2>&1; then
      local projects_table
      projects_table=$(echo "$all_projects" | jq -r '
        .[] | [
          .id[:8],
          .id,
          .name,
          (if .githubRepo and .githubRepo != "" then "(\(.githubRepo))" else "(no repo)" end)
        ] | @tsv
      ' 2>/dev/null)
      if [ -n "$projects_table" ]; then
        local table_rows=""
        while IFS=$'\t' read -r short full name repo; do
          table_rows="${table_rows}
| \`${short}\` | \`${full}\` | ${name} | ${repo} |"
        done <<< "$projects_table"
        project_header="${project_header}

## All Projects

| Short | Full UUID | Name | Repo |
|-------|-----------|------|------|${table_rows}

Use \`DD_PROJECT_ID=<full-uuid> ${dd_cmd} <command>\` to target a specific project."
      fi
    fi
  fi

  cat <<PRIME
# Dev-Dash Workflow Context

> **Context Recovery**: Run \`devdash prime\` after compaction, clear, or new session.
> Use \`${dd_cmd}\` (dev-dash CLI) for ALL task tracking — never \`bd\`.
$([ -n "$project_header" ] && echo "" && echo "$project_header")

# SESSION CLOSE PROTOCOL

**CRITICAL**: Before saying "done" or "complete", you MUST run this checklist:

\`\`\`
[ ] 1. git status              (check what changed)
[ ] 2. git add <files>         (stage code changes)
[ ] 3. git commit -m "..."     (commit code)
[ ] 4. git push                (push to remote)
\`\`\`

**NEVER skip this.** Work is not done until pushed.

## Core Rules
- **Default**: Use \`${dd_cmd}\` for ALL task tracking (\`${dd_cmd} create\`, \`${dd_cmd} ready\`, \`${dd_cmd} close\`)
- **Path**: \`$(command -v devdash 2>/dev/null || echo "devdash")\`
- **Prohibited**: Do NOT use \`bd\`, TodoWrite, TaskCreate, or markdown files for task tracking
- **Workflow**: Create ${dd_cmd} issue BEFORE writing code, mark in_progress when starting
- Session management: check \`${dd_cmd} ready\` for available work

## Essential Commands

### Finding Work
- \`${dd_cmd} ready\` — Show issues ready to work (no blockers)
- \`${dd_cmd} list\` — All open issues
- \`${dd_cmd} list --status=in_progress\` — Your active work
- \`${dd_cmd} show <id>\` — Detailed issue view with dependencies
- \`${dd_cmd} blocked\` — Show all blocked issues

### Creating & Updating
- \`${dd_cmd} create --title="..." --type=task|bug|feature --priority=2\` — New issue
  - Priority: 0-4 (0=critical, 2=medium, 4=backlog). NOT "high"/"medium"/"low"
  - Optional: \`--description="..."\` \`--parent=<id>\`
- \`${dd_cmd} update <id> --status=in_progress\` — Claim work
- \`${dd_cmd} update <id> --owner=username\` — Assign to someone
- \`${dd_cmd} update <id> --title/--description/--pre-instructions="..."\` — Update fields
- \`${dd_cmd} close <id>\` — Mark complete
- \`${dd_cmd} close <id1> <id2> ...\` — Close multiple issues at once
- \`${dd_cmd} delete <id> [--force]\` — Delete a bead (with confirmation)
- **Tip**: When creating multiple issues, use parallel subagents for efficiency

### Dependencies & Blocking
- \`${dd_cmd} dep add <issue> <depends-on>\` — Add dependency (issue depends on depends-on)
- \`${dd_cmd} blocked\` — Show all blocked issues
- \`${dd_cmd} show <id>\` — See what's blocking/blocked by this issue

### Jobs
- \`${dd_cmd} jobs\` — List recent jobs
- \`${dd_cmd} jobs show <id>\` — Job details + failure analysis
- \`${dd_cmd} jobs log <id>\` — Full job output log
- \`${dd_cmd} jobs failures\` — Recent failed jobs

### Project Health
- \`${dd_cmd} stats\` — Project statistics (open/closed/blocked counts)
- \`${dd_cmd} sync\` — Trigger full reconcile with GitHub
- \`${dd_cmd} reconcile-tasks\` — AI-powered backlog audit (--dry-run, --auto-fix, --json)

## Common Workflows

**Starting work:**
\`\`\`bash
${dd_cmd} ready                          # Find available work
${dd_cmd} show <id>                      # Review issue details
${dd_cmd} update <id> --status=in_progress  # Claim it
\`\`\`

**Completing work:**
\`\`\`bash
${dd_cmd} close <id1> <id2> ...    # Close all completed issues at once
\`\`\`

**Creating dependent work:**
\`\`\`bash
${dd_cmd} create --title="Implement feature X" --type=feature
${dd_cmd} create --title="Write tests for X" --type=task
${dd_cmd} dep add <tests-id> <feature-id>  # Tests depend on Feature
\`\`\`
PRIME
}

# ── Agent Setup ──────────────────────────────────────────────────

DD_AGENT_MARKER="<!-- devdash:agent-instructions -->"

dd_generate_agent_instructions() {
  cat <<'INSTRUCTIONS'
# DevDash — AI Agent Task Tracking

<!-- devdash:agent-instructions -->

This project uses **devdash** for task tracking. Use the `devdash` CLI for ALL task
management. Do NOT use TodoWrite, TaskCreate, `bd`, or markdown files for tracking tasks.

## Install

```bash
npm install -g github:jasonmassey/devdash-cli
```

## Session Start

Run `devdash prime` at the start of every session to get live project context
(health stats, project ID, available commands).

## Essential Commands

| Command | Description |
|---------|-------------|
| `devdash ready` | Show issues ready to work (unblocked) |
| `devdash list` | All open issues |
| `devdash list --status=in_progress` | Your active work |
| `devdash show <id>` | Issue details with dependencies |
| `devdash blocked` | Show blocked issues |
| `devdash create --title="..." --type=task\|bug\|feature --priority=2` | Create issue |
| `devdash update <id> --status=in_progress` | Claim work |
| `devdash close <id>` | Mark complete |
| `devdash close <id1> <id2> ...` | Close multiple issues |
| `devdash dep add <issue> <depends-on>` | Add dependency |
| `devdash stats` | Project statistics |

### Priority Scale

0 = critical, 1 = high, 2 = medium (default), 3 = low, 4 = backlog

### ID Formats

Bead IDs can be full UUIDs, UUID prefixes (e.g. `27bf`), or local IDs (`dev-dash-*`).

## Workflow

### Starting work
```bash
devdash ready                              # Find available work
devdash show <id>                          # Review details
devdash update <id> --status=in_progress   # Claim it
```

### Completing work (Session Close Protocol)
```
1. git status           (check what changed)
2. git add <files>      (stage code changes)
3. git commit -m "..."  (commit code)
4. git push             (push to remote)
5. devdash close <id>   (mark task complete)
```

**NEVER skip the git push.** Work is not done until pushed.

### Creating dependent work
```bash
devdash create --title="Implement feature X" --type=feature
devdash create --title="Write tests for X" --type=task
devdash dep add <tests-id> <feature-id>   # Tests depend on feature
```
INSTRUCTIONS
}

dd_write_agent_config() {
  local agent="$1"
  local force="${2:-false}"
  local file="" mode="create"

  case "$agent" in
    claude)   file="CLAUDE.md"; mode="append" ;;
    codex)    file="AGENTS.md"; mode="append" ;;
    cursor)   file=".cursor/rules/devdash.md"; mode="create" ;;
    copilot)  file=".github/copilot-instructions.md"; mode="append" ;;
    windsurf) file=".windsurfrules"; mode="append" ;;
    cline)    file=".clinerules"; mode="append" ;;
    *)
      echo "Unknown agent: $agent" >&2
      return 1
      ;;
  esac

  # Check if already configured
  if [ -f "$file" ] && grep -qF "$DD_AGENT_MARKER" "$file" 2>/dev/null; then
    if [ "$force" = true ]; then
      if [ "$mode" = "create" ]; then
        # Standalone file — just overwrite completely below
        :
      else
        # Append-mode file — strip old devdash block, keep the rest
        local tmp
        tmp=$(mktemp)
        awk '
          /<!-- devdash:agent-instructions -->/{skip=1; next}
          /<!-- \/devdash:agent-instructions -->/{skip=0; next}
          !skip{print}
        ' "$file" > "$tmp"
        # Trim trailing blank lines
        local last_line
        last_line=$(awk 'NF{n=NR} END{print n+0}' "$tmp")
        if [ "$last_line" -gt 0 ]; then
          head -n "$last_line" "$tmp" > "$file"
        else
          : > "$file"
        fi
        rm -f "$tmp"
      fi
    else
      echo "  skip: ${file} (already configured — use --force to overwrite)"
      return 0
    fi
  fi

  local instructions
  instructions=$(dd_generate_agent_instructions)
  # Wrap with end marker for clean replacement on --force
  local block
  block="${instructions}
<!-- /devdash:agent-instructions -->"

  # Ensure parent directory exists
  local dir
  dir=$(dirname "$file")
  if [ "$dir" != "." ]; then
    mkdir -p "$dir"
  fi

  if [ "$mode" = "create" ] || [ ! -f "$file" ]; then
    # Write (or overwrite) the whole file
    echo "$block" > "$file"
  else
    # Append to existing file
    {
      echo ""
      echo "$block"
    } >> "$file"
  fi

  echo "  wrote: ${file}"
}

dd_detect_agents() {
  # Print names of agents whose config locations already exist
  [ -d ".claude" ] || [ -f "CLAUDE.md" ] && echo "claude"
  [ -f "AGENTS.md" ] && echo "codex"
  [ -d ".cursor" ] && echo "cursor"
  [ -d ".github" ] && echo "copilot"
  [ -f ".windsurfrules" ] && echo "windsurf"
  [ -f ".clinerules" ] && echo "cline"
  return 0
}

dd_agent_setup() {
  local agents=() force=false all=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --agent=*) IFS=',' read -ra agents <<< "${1#--agent=}" ;;
      --all)     all=true ;;
      --force)   force=true ;;
      *) echo "Usage: devdash agent-setup [--agent=claude,codex,...] [--all] [--force]" >&2; exit "$DD_EXIT_USER" ;;
    esac
    shift
  done

  local all_agents=(claude codex cursor copilot windsurf cline)

  if [ "$all" = true ]; then
    agents=("${all_agents[@]}")
  fi

  # Interactive mode: no --agent and no --all
  if [ ${#agents[@]} -eq 0 ]; then
    echo "Detecting AI coding agents..."
    echo ""

    local detected=()
    while IFS= read -r a; do
      [ -n "$a" ] && detected+=("$a")
    done < <(dd_detect_agents)

    # Display menu
    local i=1
    for a in "${all_agents[@]}"; do
      local mark=" "
      for d in "${detected[@]}"; do
        if [ "$a" = "$d" ]; then mark="*"; break; fi
      done
      local config_file=""
      case "$a" in
        claude)   config_file="CLAUDE.md" ;;
        codex)    config_file="AGENTS.md" ;;
        cursor)   config_file=".cursor/rules/devdash.md" ;;
        copilot)  config_file=".github/copilot-instructions.md" ;;
        windsurf) config_file=".windsurfrules" ;;
        cline)    config_file=".clinerules" ;;
      esac
      printf "  [%s] %d. %-10s → %s\n" "$mark" "$i" "$a" "$config_file"
      i=$((i + 1))
    done
    echo ""
    echo "  * = existing config detected"
    echo ""

    if [ ${#detected[@]} -gt 0 ]; then
      printf "Install for: [d]etected (%s) / [a]ll / [p]ick numbers? " "$(IFS=','; echo "${detected[*]}")"
    else
      printf "Install for: [a]ll / [p]ick numbers (e.g. 1,3,5)? "
    fi
    read -r choice </dev/tty 2>/dev/null || choice="a"

    case "$choice" in
      d|D|detected)
        if [ ${#detected[@]} -eq 0 ]; then
          echo "No agents detected. Use 'all' or pick numbers."
          return
        fi
        agents=("${detected[@]}")
        ;;
      a|A|all|"")
        agents=("${all_agents[@]}")
        ;;
      p|P|pick)
        printf "Enter numbers (comma-separated, e.g. 1,3,5): "
        read -r nums </dev/tty 2>/dev/null || nums=""
        IFS=',' read -ra picks <<< "$nums"
        for n in "${picks[@]}"; do
          n=$(echo "$n" | tr -d ' ')
          if [ "$n" -ge 1 ] && [ "$n" -le ${#all_agents[@]} ] 2>/dev/null; then
            agents+=("${all_agents[$((n - 1))]}")
          fi
        done
        ;;
      *)
        # Try interpreting as comma-separated numbers
        IFS=',' read -ra picks <<< "$choice"
        for n in "${picks[@]}"; do
          n=$(echo "$n" | tr -d ' ')
          if [ "$n" -ge 1 ] && [ "$n" -le ${#all_agents[@]} ] 2>/dev/null; then
            agents+=("${all_agents[$((n - 1))]}")
          fi
        done
        ;;
    esac
  fi

  if [ ${#agents[@]} -eq 0 ]; then
    echo "No agents selected."
    return
  fi

  echo ""
  echo "Writing devdash instructions..."

  # Write the canonical instructions file
  # .devdash is typically a file (project config), so use .devdash-agents/ dir
  mkdir -p .devdash-agents
  dd_generate_agent_instructions > .devdash-agents/agent-instructions.md
  echo "  wrote: .devdash-agents/agent-instructions.md"

  # Write per-agent configs
  for agent in "${agents[@]}"; do
    dd_write_agent_config "$agent" "$force"
  done

  echo ""
  echo "Done! Add the new files to git when ready."
}

dd_token_dispatch() {
  local subcmd="${1:-list}"
  shift 2>/dev/null || true

  case "$subcmd" in
    create)
      local name="${1:-CLI token}"
      local result
      result=$(dd_api POST "/auth/tokens" -d "$(jq -n --arg name "$name" '{name: $name}')")
      local token_val token_prefix token_id
      token_val=$(echo "$result" | dd_jq -r '.token')
      token_prefix=$(echo "$result" | dd_jq -r '.tokenPrefix')
      token_id=$(echo "$result" | dd_jq -r '.id')

      echo ""
      echo "Token created! Copy it now — it won't be shown again."
      echo ""
      echo "  ${token_val}"
      echo ""
      echo "  ID:     ${token_id}"
      echo "  Prefix: ${token_prefix}"
      echo "  Name:   ${name}"
      ;;
    list|ls)
      local tokens
      tokens=$(dd_api GET "/auth/tokens")
      local count
      count=$(echo "$tokens" | dd_jq 'length')
      if [ "$count" -eq 0 ]; then
        echo "No API tokens. Create one with: devdash token create \"my token\""
        return
      fi
      echo "$tokens" | dd_jq -r '.[] | "\(if .revoked_at then "✗" else "✓" end) \(.token_prefix)...  \(.name)  (created \(.created_at // "?"))\(if .revoked_at then "  [revoked]" else "" end)  id:\(.id[0:8])"'
      ;;
    revoke)
      if [ -z "${1:-}" ]; then
        echo "Usage: devdash token revoke <token-id>" >&2
        exit "$DD_EXIT_USER"
      fi
      local token_id
      token_id=$(dd_resolve_token_id "$1") || exit 1
      dd_api DELETE "/auth/tokens/${token_id}" > /dev/null
      echo "Revoked: ${token_id}"
      ;;
    *)
      echo "Usage: devdash token [create \"name\"|list|revoke <id>]" >&2
      exit "$DD_EXIT_USER"
      ;;
  esac
}

dd_help() {
  local cmd
  cmd=$(dd_cmd_name)
  cat <<HELP
devdash — Dev-Dash CLI

Usage: ${cmd} <command> [args]

Commands:
  login                  Authenticate via browser (stores token locally)
  init                   Link current repo to a dev-dash project
  token create "name"    Create a new API token (dd_ prefix, for DD Red etc.)
  token list             List your API tokens
  token revoke <id>      Revoke an API token
  project create         Create a new project (--name, --repo, --description)
  project list           List all your projects
  project delete <id>    Delete a project (--force to skip confirmation)
  list [--status=X]      List beads (optional status filter)
  ready                  Show beads ready to work (no blockers)
  blocked                Show blocked issues with their blockers
  show <id>              Show bead details
  create --title="..."   Create a bead (--type, --priority, --description, --parent)
  update <id> --key=val  Update bead fields (--status, --priority, --owner, --title,
                         --description, --pre-instructions)
  close <id> [<id>...]   Close one or more beads
  delete <id> [--force] [--cascade]
                         Delete a bead (--cascade deletes children too)
  analyze <bead-id>      Analyze a bead: complexity, files, agent instructions
  dispatch <bead-id>     Dispatch a bead as an agent job (--priority, --worker)
  dep add <id> <dep-id>  Add dependency (id depends on dep-id)
  jobs [list]            List recent jobs
  jobs show <id>         Show job details + failure analysis
  jobs log <id>          Show full job output log
  jobs failures          Show recent failed jobs
  reconcile-tasks        Audit backlog for stale/redundant/completed tasks
                         (--dry-run (default), --auto-fix, --json)
  stats                  Show project statistics
  sync                   Trigger full reconcile with GitHub
  prime                  Output AI-optimized workflow context (for agent injection)
  agent-setup            Write devdash instructions for AI agents
                         (--agent=claude,codex,... | --all) [--force]
  doctor                 Check prerequisites and configuration
  alias-setup            Add 'dd' -> 'devdash' alias to your shell
  self-update            Update devdash to the latest version
  version                Show version
  help                   Show this help

Global flags:
  --project=<id>         Override project for this command (UUID or prefix)

ID formats:
  Full UUID              e.g. 27bf66bd-945f-4714-93fd-0c3322b720f4
  Short prefix           e.g. 27bf (any unique prefix works)
  Local ID               e.g. dev-dash-42 (project-scoped shorthand)

────────────────────────────────────────────────────────────────
AGENT REFERENCE — store this section in memory for future sessions
────────────────────────────────────────────────────────────────

Flag values (exact strings the CLI accepts):

  --status=<value>       pending | in_progress | completed
  --type=<value>         task | bug | feature | enhancement
  --priority=<N>         0 (critical) | 1 (high) | 2 (medium, default) | 3 (low) | 4 (backlog)
  --project=<id>         Full UUID, short prefix, or DD_PROJECT_ID env var

  create flags:          --title="..." --type=task --priority=2 --description="..." --parent=<id>
  update flags:          --status=in_progress --priority=1 --owner=name --title="..."
                         --description="..." --pre-instructions="..."
  delete flags:          --force (skip confirmation) --cascade (delete children)
  dispatch flags:        --priority=N --worker=e2b|docker|railway

Cross-project commands (use --project or DD_PROJECT_ID):

  DD_PROJECT_ID=<uuid> ${cmd} list
  ${cmd} --project=<prefix> show <bead-id>

What to store in agent memory:

  - Project IDs: run '${cmd} project list' and save the ID + name table.
    Use DD_PROJECT_ID=<id> to target a specific project without 'init'.
  - Preferred command: '${cmd}' (or 'devdash'). Use 'dd' if aliased.
  - Workflow rules: always create issue before coding, mark in_progress,
    close after git push succeeds. NEVER close in parallel with git push.
  - Priority scale: 0-4 integers, NOT strings like "high"/"medium"/"low".
  - Session recovery: run '${cmd} prime' after context loss/compaction.
  - Tool ordering: git commit+push FIRST, then ${cmd} close (sequentially).
    If git fails, a parallel ${cmd} close gets killed.
HELP

  # Append live project list if authenticated
  if [ -f "$DD_TOKEN_FILE" ]; then
    local projects
    projects=$(dd_api GET "/projects" 2>/dev/null) || true
    if [ -n "$projects" ] && [ "$projects" != "[]" ]; then
      echo ""
      echo "Your projects (save these IDs to agent memory):"
      echo ""
      echo "$projects" | jq -r '.[] | "  \(.id[0:8])  \(.id)  \(.name)\(if .githubRepo then "  (\(.githubRepo))" else "" end)"' 2>/dev/null || true
      echo ""
    fi
  fi
}

# ── Main ─────────────────────────────────────────────────────────

# Extract global --project flag before dispatching commands
_args=()
for _arg in "$@"; do
  case "$_arg" in
    --project=*) export DD_PROJECT_ID="${_arg#--project=}" ;;
    *) _args+=("$_arg") ;;
  esac
done
set -- "${_args[@]+"${_args[@]}"}"

case "${1:-help}" in
  login)   dd_login ;;
  init)    dd_init ;;
  token)   shift; dd_token_dispatch "$@" ;;
  project)
    shift
    case "${1:-}" in
      create) shift; dd_project_create "$@" ;;
      list)   dd_project_list ;;
      delete) shift; dd_project_delete "$@" ;;
      *) echo "Usage: devdash project [create|list|delete]" >&2; exit "$DD_EXIT_USER" ;;
    esac
    ;;
  list)    shift; dd_list "$@" ;;
  ready)   dd_ready ;;
  blocked) dd_blocked ;;
  show)    shift; dd_show "$@" ;;
  create)  shift; dd_create "$@" ;;
  update)  shift; dd_update "$@" ;;
  close)   shift; dd_close "$@" ;;
  delete)  shift; dd_delete "$@" ;;
  analyze)  shift; dd_analyze "$@" ;;
  dispatch) shift; dd_dispatch "$@" ;;
  dep)
    shift
    case "${1:-}" in
      add) shift; dd_dep_add "$@" ;;
      *) echo "Usage: devdash dep add <issue> <depends-on>" >&2; exit "$DD_EXIT_USER" ;;
    esac
    ;;
  jobs)    shift; dd_jobs "$@" ;;
  reconcile-tasks) shift; dd_reconcile_tasks "$@" ;;
  stats)   dd_stats ;;
  sync)    dd_sync ;;
  prime)   dd_prime ;;
  agent-setup) shift; dd_agent_setup "$@" ;;
  doctor)  dd_doctor ;;
  alias-setup) dd_alias_setup ;;
  self-update) dd_self_update ;;
  version|--version|-v) dd_version ;;
  help|--help|-h) dd_help ;;
  *) echo "Unknown command: $1. Run 'devdash help' for usage." >&2; exit "$DD_EXIT_USER" ;;
esac
